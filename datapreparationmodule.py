# -*- coding: utf-8 -*-
"""dataPreparationModule.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GsP6citvjDcHcqIZC6ioLfwaI9TPFbar
"""

import numpy as np
import pandas as pd

def dataframeToDict(df):

  # Description
  # -----------
  # This function converts the dataframe which containts the dataset into a dictonary with the same data.
  

  # Function inputs
  # -----------------
  # - df(dataframe): The dataframe which contains the dataset.

  # Function Outputs
  # -----------------
  # - dictReturn(dictionary): The dictionary which contains the same data.

  timeDataString = df.iloc[:, 0]
  sunspotData = df.iloc[:, 1]


  timeDataMonths = [(int(timeDataString[i].split('-')[0])-1749)*12+int(timeDataString[i].split('-')[1])-1 for i in range(len(timeDataString))]
                     
  dictReturn = {}
  dictReturn[0] = timeDataMonths
  dictReturn[1] = sunspotData
  dictReturn['dt'] = 1



  return dictReturn

def downSampleData(dictData,dtMonths):

  # Description
  # -----------
  # This function downsamples the sunspot observation data. For instance if we pass
  # observational data with time step of 1 months and dtMonths=2, the function
  # will return the same data but with the time step of 2 months. 

  # Function inputs
  # -----------------
  # - dictData(dictionary): The dictonary that contains the sunspot data that will be downsampled.
  # - dtMonths(integer): The downsample factor.

  # Function Outputs
  # -----------------
  # - downSampledDataDict(dictionary): Downsampled data (a pandas dataframe).
   


   timeData = dictData[0]
   sunspotData = dictData[1]

   timeDataDownsampled = [timeData[i] for i in range(len(timeData)) if timeData[i]%dtMonths==0]
   sunspotDataDownsampled = []


   for i in timeDataDownsampled:

     valueToAppend = sum([sunspotData[i+j] for j in range(dtMonths)])
     sunspotDataDownsampled.append(valueToAppend)

   downSampledDataDict = {}

   downSampledDataDict[0] = timeDataDownsampled
   downSampledDataDict[1] = sunspotDataDownsampled
   downSampledDataDict['dt'] = dtMonths

   return downSampledDataDict

def trainTestSplit(dictData,trainPrec):

  # Description
  # -----------
  # This function splits the time-series data into 2 parts.One part is used to train
  # the PySINDy model. The other part is the test data and can be used to
  # check the accuracy of the trained PySINDy model.

  # Function inputs
  # -----------------
  # - dictData(dictionary): The dataset that will be split.
  # - trainPrec(float): The ratio of training data length to the length of the entire dataset.

  # Function Outputs
  # -----------------
  # trainArray(numpy array): The training array.
  # trainTime(numpy array): The time instants for the training array.
  # testArray(numpy array): The test array.
  # testTime(numpy array):  The time instants for the test array.

   timeData = dictData[0]
   sunspotData = dictData[1]

   timeThreshold = int(trainPrec*(timeData[-1]-timeData[0]))+timeData[0]

   trainTime = [timeData[i] for i in range(len(timeData)) if timeData[i]<timeThreshold]
   trainArray= [sunspotData[i] for i in range(len(timeData)) if timeData[i]<timeThreshold]

   testTime = [timeData[i] for i in range(len(timeData)) if timeData[i]>timeThreshold]
   testArray = [sunspotData[i] for i in range(len(timeData)) if timeData[i]>timeThreshold]




   return trainArray,trainTime,testArray,testTime

def cropData(dictData,startDate,stopDate):

  #  Description
  #  -----------
  #  This function crops the entire sunspot observation dataset using start
  #  and end dates specified.

  #   Function inputs
  # -----------------
  # - dictData(dictionary): The dataset that will be cropped.
  # - startDate(string): The start date. 
  # - endDate(string): The end date.

  #   Function Outputs
  # -----------------
  # - croppedDataDict: The cropped dataframe (a pandas dataframe).
   

   timeData = dictData[0]
   sunspotData = dictData[1]
   
   startDateMonth = (int(startDate.split('-')[0])-1749)*12+int(startDate.split('-')[1])-1
   stopDateMonth =  (int(stopDate.split('-')[0])-1749)*12+int(stopDate.split('-')[1])
  
   sunspotDataCropped = sunspotData[startDateMonth:stopDateMonth]
   timeDataCroppeed = timeData[startDateMonth:stopDateMonth]

  


   croppedDataDict = {}

   croppedDataDict[0] = timeDataCroppeed
   croppedDataDict[1] = sunspotDataCropped
   croppedDataDict['dt'] = dictData['dt']

   return croppedDataDict

def generateData(df,dataParams):

  # This function composes other functions in this module to generate training and
  # test data from the loaded dataset. 

  # Function Inputs
  # ----------------
  # df(pandas dataframe): The dataset in pandas dataframe format.
  # dataParams(list): The parameters for generation of the data.

  # Function Outputs
  # ----------------
  # trainArray(numpy array): The training array.
  # trainTime(numpy array): The time instants for the training array.
  # testArray(numpy array): The test array.
  # testTime(numpy array):  The time instants for the test array. 
   
  # Unpacking the parameters. 
  dt = dataParams['dt']
  startDate = dataParams['startDate']
  endDate = dataParams['endDate']
  trainingPrec = dataParams['trainingPrec']

  dataDictUnprocessed = dataframeToDict(df)
  dataDictCropped = cropData(dataDictUnprocessed,startDate,endDate)
  dataDictDownsampled = downSampleData(dataDictCropped,dt)
  trainArray,trainTime,testArray,testTime  = trainTestSplit(dataDictDownsampled,trainingPrec)

  # Converting to numpy arrays. 
  trainArray = np.array(trainArray)
  trainTime = np.array(trainTime)
  testArray = np.array(testArray)
  testTime = np.array(testTime)



  return trainArray,trainTime,testArray,testTime

def smoothTimeSeries(timeSeries,windowLength):

  # This function applies a simple smoothing filter (averaging) to the inputted time series. 

  # Function Inputs
  # ----------------
  # timeSeries(numpy array): The array which contains time series to be smoothed. 
  # windowLength(integer): The window length.
  
  # Function Outputs
  # ----------------
  # timeSeriesSmoothed(numpy array): The smoothed time series.


   timeSeriesSmoothed = np.zeros(timeSeries.shape[0])

   for t in range(len(timeSeries)):
    if t<windowLength:
     timeSeriesSmoothed[t] = np.mean(timeSeries[:t+1])
    else:
     timeSeriesSmoothed[t] = np.sum(timeSeries[t-windowLength:t])/windowLength
 
  	
   return timeSeriesSmoothed

def timeseriesIntoSupervised(array,nin=1,nout=1):

  # This function converts a time series data into data suitible for
  # supervised learning problem by applying windowing method. 

  # Function Inputs
  # ----------------
  # array(numpy array): The array containing the time series.
  # nin(integer): The dimension of the feature space.
  # nout(integer): The number of target variables(y) which will be predicted.

  # Function Outputs
  # ----------------
  # X(numpy array): The array containing feautre values.
  # y(numpy array): The array containing the target values.
  # normalizationParams(list): The parameters which were used to normalize the time series.


  windowSize = nin+nout
  dataLen = len(array)

  dataMin = np.amin(array)
  dataMax = np.amax(array)
  normalizationParams = [dataMin,dataMax]

  array = (array - dataMin)/(dataMax-dataMin)

  X = []
  y = []
  XAppend = []
  yAppend = []

  for i in range(dataLen-windowSize+1):

    XAppend = [array[i+j] for j in range(nin)]
    yAppend = [array[i+j]-array[i+j-1] for j in range(nin,nin+nout)]

    X.append(XAppend)
    y.append(yAppend)



  X = np.array(X)
  y = np.array(y)

  

  return X,y,normalizationParams

def supervisedIntoTimeseries(X,y,normalizationParams):

  # This function converts data back to timeseries.

  # Function Inputs
  # ----------------
  # X(numpy array): The feature vectors of the supervised array.
  # y(numpy array): The target variables of the supervised array.
  # normalizationParams(list): The normalization parameters generated by the function 'timeseriesIntoSupervised'.

  # Function Outputs
  # ----------------
  # timeSeries(numpy array): The recovered time series.
  
  timeSeries = np.array(X[0,:])
  dataMin = normalizationParams[0]
  dataMax = normalizationParams[1]

  for i in range(y.shape[0]):

    yToAppend = timeSeries[-1] + y[i]
    timeSeries = np.append(timeSeries,yToAppend)


  timeSeries = timeSeries*(dataMax-dataMin) + dataMin


  return timeSeries